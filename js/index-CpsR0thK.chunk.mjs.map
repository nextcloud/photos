{"version":3,"file":"index-CpsR0thK.chunk.mjs","sources":["../node_modules/node-stdlib-browser/node_modules/path-browserify/index.js","../node_modules/p-timeout/index.js","../node_modules/p-queue/dist/lower-bound.js","../node_modules/p-queue/dist/priority-queue.js","../node_modules/p-queue/dist/index.js"],"sourcesContent":["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","export class TimeoutError extends Error {\n\tname = 'TimeoutError';\n\n\tconstructor(message, options) {\n\t\tsuper(message, options);\n\t\tError.captureStackTrace?.(this, TimeoutError);\n\t}\n}\n\nconst getAbortedReason = signal => signal.reason ?? new DOMException('This operation was aborted.', 'AbortError');\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t\tsignal,\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (signal?.aborted) {\n\t\t\treject(getAbortedReason(signal));\n\t\t\treturn;\n\t\t}\n\n\t\tif (signal) {\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\t// Use .then() instead of async IIFE to preserve stack traces\n\t\t// eslint-disable-next-line promise/prefer-await-to-then, promise/prefer-catch\n\t\tpromise.then(resolve, reject);\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\t// `.call(undefined, ...)` is needed for custom timers to avoid context issues\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\t});\n\n\t// eslint-disable-next-line promise/prefer-await-to-then\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && signal) {\n\t\t\tsignal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\t// `.call(undefined, ...)` is needed for custom timers to avoid context issues\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        const { priority = 0, id, } = options ?? {};\n        const element = {\n            priority,\n            id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverIntervalCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #rateLimitedInInterval = false;\n    #rateLimitFlushScheduled = false;\n    #interval;\n    #intervalEnd = 0;\n    #lastExecutionTime = 0;\n    #intervalId;\n    #timeoutId;\n    #strict;\n    // Circular buffer implementation for better performance\n    #strictTicks = [];\n    #strictTicksStartIndex = 0;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    // Track currently running tasks for debugging\n    #runningTasks = new Map();\n    /**\n    Get or set the default timeout for all tasks. Can be changed at runtime.\n\n    Operations will throw a `TimeoutError` if they don't complete within the specified time.\n\n    The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.\n\n    @example\n    ```\n    const queue = new PQueue({timeout: 5000});\n\n    // Change timeout for all future tasks\n    queue.timeout = 10000;\n    ```\n    */\n    timeout;\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverIntervalCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            strict: false,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        if (options.strict && options.interval === 0) {\n            throw new TypeError('The `strict` option requires a non-zero `interval`');\n        }\n        if (options.strict && options.intervalCap === Number.POSITIVE_INFINITY) {\n            throw new TypeError('The `strict` option requires a finite `intervalCap`');\n        }\n        // TODO: Remove this fallback in the next major version\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        this.#carryoverIntervalCount = options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#strict = options.strict;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        if (options.timeout !== undefined && !(Number.isFinite(options.timeout) && options.timeout > 0)) {\n            throw new TypeError(`Expected \\`timeout\\` to be a positive finite number, got \\`${options.timeout}\\` (${typeof options.timeout})`);\n        }\n        this.timeout = options.timeout;\n        this.#isPaused = options.autoStart === false;\n        this.#setupRateLimitTracking();\n    }\n    #cleanupStrictTicks(now) {\n        // Remove ticks outside the current interval window using circular buffer approach\n        while (this.#strictTicksStartIndex < this.#strictTicks.length) {\n            const oldestTick = this.#strictTicks[this.#strictTicksStartIndex];\n            if (oldestTick !== undefined && now - oldestTick >= this.#interval) {\n                this.#strictTicksStartIndex++;\n            }\n            else {\n                break;\n            }\n        }\n        // Compact the array when it becomes inefficient or fully consumed\n        // Compact when: (start index is large AND more than half wasted) OR all ticks expired\n        const shouldCompact = (this.#strictTicksStartIndex > 100 && this.#strictTicksStartIndex > this.#strictTicks.length / 2)\n            || this.#strictTicksStartIndex === this.#strictTicks.length;\n        if (shouldCompact) {\n            this.#strictTicks = this.#strictTicks.slice(this.#strictTicksStartIndex);\n            this.#strictTicksStartIndex = 0;\n        }\n    }\n    // Helper methods for interval consumption\n    #consumeIntervalSlot(now) {\n        if (this.#strict) {\n            this.#strictTicks.push(now);\n        }\n        else {\n            this.#intervalCount++;\n        }\n    }\n    #rollbackIntervalSlot() {\n        if (this.#strict) {\n            // Pop from the end of the actual data (not from start index)\n            if (this.#strictTicks.length > this.#strictTicksStartIndex) {\n                this.#strictTicks.pop();\n            }\n        }\n        else if (this.#intervalCount > 0) {\n            this.#intervalCount--;\n        }\n    }\n    #getActiveTicksCount() {\n        return this.#strictTicks.length - this.#strictTicksStartIndex;\n    }\n    get #doesIntervalAllowAnother() {\n        if (this.#isIntervalIgnored) {\n            return true;\n        }\n        if (this.#strict) {\n            // Cleanup already done by #isIntervalPausedAt before this is called\n            return this.#getActiveTicksCount() < this.#intervalCap;\n        }\n        return this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        if (this.#pending === 0) {\n            this.emit('pendingZero');\n        }\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        // Clear timeout ID before processing to prevent race condition\n        // Must clear before #onInterval to allow new timeouts to be scheduled\n        this.#timeoutId = undefined;\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n    }\n    #isIntervalPausedAt(now) {\n        // Strict mode: check if we need to wait for oldest tick to age out\n        if (this.#strict) {\n            this.#cleanupStrictTicks(now);\n            // If at capacity, need to wait for oldest tick to age out\n            const activeTicksCount = this.#getActiveTicksCount();\n            if (activeTicksCount >= this.#intervalCap) {\n                const oldestTick = this.#strictTicks[this.#strictTicksStartIndex];\n                // After cleanup, remaining ticks are within interval, so delay is always > 0\n                const delay = this.#interval - (now - oldestTick);\n                this.#createIntervalTimeout(delay);\n                return true;\n            }\n            return false;\n        }\n        // Fixed window mode (original logic)\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // If the interval has expired while idle, check if we should enforce the interval\n                // from the last task execution. This ensures proper spacing between tasks even\n                // when the queue becomes empty and then new tasks are added.\n                if (this.#lastExecutionTime > 0) {\n                    const timeSinceLastExecution = now - this.#lastExecutionTime;\n                    if (timeSinceLastExecution < this.#interval) {\n                        // Not enough time has passed since the last task execution\n                        this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);\n                        return true;\n                    }\n                }\n                // Enough time has passed or no previous execution, allow execution\n                this.#intervalCount = (this.#carryoverIntervalCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                this.#createIntervalTimeout(delay);\n                return true;\n            }\n        }\n        return false;\n    }\n    #createIntervalTimeout(delay) {\n        if (this.#timeoutId !== undefined) {\n            return;\n        }\n        this.#timeoutId = setTimeout(() => {\n            this.#onResumeInterval();\n        }, delay);\n    }\n    #clearIntervalTimer() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n    }\n    #clearTimeoutTimer() {\n        if (this.#timeoutId) {\n            clearTimeout(this.#timeoutId);\n            this.#timeoutId = undefined;\n        }\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            this.#clearIntervalTimer();\n            this.emit('empty');\n            if (this.#pending === 0) {\n                // Clear timeout as well when completely idle\n                this.#clearTimeoutTimer();\n                // Compact strict ticks when idle to free memory\n                if (this.#strict && this.#strictTicksStartIndex > 0) {\n                    const now = Date.now();\n                    this.#cleanupStrictTicks(now);\n                }\n                this.emit('idle');\n            }\n            return false;\n        }\n        let taskStarted = false;\n        if (!this.#isPaused) {\n            const now = Date.now();\n            const canInitializeInterval = !this.#isIntervalPausedAt(now);\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!this.#isIntervalIgnored) {\n                    this.#consumeIntervalSlot(now);\n                    this.#scheduleRateLimitUpdate();\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                taskStarted = true;\n            }\n        }\n        return taskStarted;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        // Strict mode uses timeouts instead of interval timers\n        if (this.#strict) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        // Non-strict mode uses interval timers and intervalCount\n        if (!this.#strict) {\n            if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n                this.#clearIntervalTimer();\n            }\n            this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;\n        }\n        this.#processQueue();\n        this.#scheduleRateLimitUpdate();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => 'ðŸ¦„', {priority: 1});\n    queue.add(async () => 'ðŸ¦€', {priority: 0, id: 'ðŸ¦€'});\n    queue.add(async () => 'ðŸ¦„', {priority: 1});\n    queue.add(async () => 'ðŸ¦„', {priority: 1});\n\n    queue.setPriority('ðŸ¦€', 2);\n    ```\n\n    In this case, the promise function with `id: 'ðŸ¦€'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => 'ðŸ¦„', {priority: 1});\n    queue.add(async () => 'ðŸ¦€', {priority: 1, id: 'ðŸ¦€'});\n    queue.add(async () => 'ðŸ¦„');\n    queue.add(async () => 'ðŸ¦„', {priority: 0});\n\n    queue.setPriority('ðŸ¦€', -1);\n    ```\n    Here, the promise function with `id: 'ðŸ¦€'` executes last.\n    */\n    setPriority(id, priority) {\n        if (typeof priority !== 'number' || !Number.isFinite(priority)) {\n            throw new TypeError(`Expected \\`priority\\` to be a finite number, got \\`${priority}\\` (${typeof priority})`);\n        }\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // Create a copy to avoid mutating the original options object\n        options = {\n            timeout: this.timeout,\n            ...options,\n            // Assign unique ID if not provided\n            id: options.id ?? (this.#idAssigner++).toString(),\n        };\n        return new Promise((resolve, reject) => {\n            // Create a unique symbol for tracking this task\n            const taskSymbol = Symbol(`task-${options.id}`);\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                // Track this running task\n                this.#runningTasks.set(taskSymbol, {\n                    id: options.id,\n                    priority: options.priority ?? 0, // Match priority-queue default\n                    startTime: Date.now(),\n                    timeout: options.timeout,\n                });\n                let eventListener;\n                try {\n                    // Check abort signal - if aborted, need to decrement the counter\n                    // that was incremented in tryToStartAnother\n                    try {\n                        options.signal?.throwIfAborted();\n                    }\n                    catch (error) {\n                        this.#rollbackIntervalConsumption();\n                        // Clean up tracking before throwing\n                        this.#runningTasks.delete(taskSymbol);\n                        throw error;\n                    }\n                    this.#lastExecutionTime = Date.now();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), {\n                            milliseconds: options.timeout,\n                            message: `Task timed out after ${options.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`,\n                        });\n                    }\n                    if (options.signal) {\n                        const { signal } = options;\n                        operation = Promise.race([operation, new Promise((_resolve, reject) => {\n                                eventListener = () => {\n                                    reject(signal.reason);\n                                };\n                                signal.addEventListener('abort', eventListener, { once: true });\n                            })]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    // Clean up abort event listener\n                    if (eventListener) {\n                        options.signal?.removeEventListener('abort', eventListener);\n                    }\n                    // Remove from running tasks\n                    this.#runningTasks.delete(taskSymbol);\n                    // Use queueMicrotask to prevent deep recursion while maintaining timing\n                    queueMicrotask(() => {\n                        this.#next();\n                    });\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n        // Clear interval timer since queue is now empty (consistent with #tryToStartAnother)\n        this.#clearIntervalTimer();\n        // Note: We preserve strict mode rate-limiting state (ticks and timeout)\n        // because clear() only clears queued tasks, not rate limit history.\n        // This ensures that rate limits are still enforced after clearing the queue.\n        // Note: We don't clear #runningTasks as those tasks are still running\n        // They will be removed when they complete in the finally block\n        // Force synchronous update since clear() should have immediate effect\n        this.#updateRateLimitState();\n        // Emit events so waiters (onEmpty, onIdle, onSizeLessThan) can resolve\n        this.emit('empty');\n        if (this.#pending === 0) {\n            this.#clearTimeoutTimer();\n            this.emit('idle');\n        }\n        this.emit('next');\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    /**\n    The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.\n\n    @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.\n    */\n    async onPendingZero() {\n        if (this.#pending === 0) {\n            return;\n        }\n        await this.#onEvent('pendingZero');\n    }\n    /**\n    @returns A promise that settles when the queue becomes rate-limited due to intervalCap.\n    */\n    async onRateLimit() {\n        if (this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimit');\n    }\n    /**\n    @returns A promise that settles when the queue is no longer rate-limited.\n    */\n    async onRateLimitCleared() {\n        if (!this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimitCleared');\n    }\n    /**\n    @returns A promise that rejects when any task in the queue errors.\n\n    Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.\n\n    Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.\n\n    @example\n    ```\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    queue.add(() => fetchData(1)).catch(() => {});\n    queue.add(() => fetchData(2)).catch(() => {});\n    queue.add(() => fetchData(3)).catch(() => {});\n\n    // Stop processing on first error\n    try {\n        await Promise.race([\n            queue.onError(),\n            queue.onIdle()\n        ]);\n    } catch (error) {\n        queue.pause(); // Stop processing remaining tasks\n        console.error('Queue failed:', error);\n    }\n    ```\n    */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    onError() {\n        return new Promise((_resolve, reject) => {\n            const handleError = (error) => {\n                this.off('error', handleError);\n                reject(error);\n            };\n            this.on('error', handleError);\n        });\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n    #setupRateLimitTracking() {\n        // Only schedule updates when rate limiting is enabled\n        if (this.#isIntervalIgnored) {\n            return;\n        }\n        // Wire up to lifecycle events that affect rate limit state\n        // Only 'add' and 'next' can actually change rate limit state\n        this.on('add', () => {\n            if (this.#queue.size > 0) {\n                this.#scheduleRateLimitUpdate();\n            }\n        });\n        this.on('next', () => {\n            this.#scheduleRateLimitUpdate();\n        });\n    }\n    #scheduleRateLimitUpdate() {\n        // Skip if rate limiting is not enabled or already scheduled\n        if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {\n            return;\n        }\n        this.#rateLimitFlushScheduled = true;\n        queueMicrotask(() => {\n            this.#rateLimitFlushScheduled = false;\n            this.#updateRateLimitState();\n        });\n    }\n    #rollbackIntervalConsumption() {\n        if (this.#isIntervalIgnored) {\n            return;\n        }\n        this.#rollbackIntervalSlot();\n        this.#scheduleRateLimitUpdate();\n    }\n    #updateRateLimitState() {\n        const previous = this.#rateLimitedInInterval;\n        // Early exit if rate limiting is disabled or queue is empty\n        if (this.#isIntervalIgnored || this.#queue.size === 0) {\n            if (previous) {\n                this.#rateLimitedInInterval = false;\n                this.emit('rateLimitCleared');\n            }\n            return;\n        }\n        // Get the current count based on mode\n        let count;\n        if (this.#strict) {\n            const now = Date.now();\n            this.#cleanupStrictTicks(now);\n            count = this.#getActiveTicksCount();\n        }\n        else {\n            count = this.#intervalCount;\n        }\n        const shouldBeRateLimited = count >= this.#intervalCap;\n        if (shouldBeRateLimited !== previous) {\n            this.#rateLimitedInInterval = shouldBeRateLimited;\n            this.emit(shouldBeRateLimited ? 'rateLimit' : 'rateLimitCleared');\n        }\n    }\n    /**\n    Whether the queue is currently rate-limited due to intervalCap.\n    */\n    get isRateLimited() {\n        return this.#rateLimitedInInterval;\n    }\n    /**\n    Whether the queue is saturated. Returns `true` when:\n    - All concurrency slots are occupied and tasks are waiting, OR\n    - The queue is rate-limited and tasks are waiting\n\n    Useful for detecting backpressure and potential hanging tasks.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Backpressure handling\n    if (queue.isSaturated) {\n        console.log('Queue is saturated, waiting for capacity...');\n        await queue.onSizeLessThan(queue.concurrency);\n    }\n\n    // Monitoring for stuck tasks\n    setInterval(() => {\n        if (queue.isSaturated) {\n            console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);\n        }\n    }, 60000);\n    ```\n    */\n    get isSaturated() {\n        return (this.#pending === this.#concurrency && this.#queue.size > 0)\n            || (this.isRateLimited && this.#queue.size > 0);\n    }\n    /**\n    The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).\n\n    Returns an array of task info objects.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Add tasks with IDs for better debugging\n    queue.add(() => fetchUser(123), {id: 'user-123'});\n    queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});\n\n    // Check what's running\n    console.log(queue.runningTasks);\n    // => [{\n    //   id: 'user-123',\n    //   priority: 0,\n    //   startTime: 1759253001716,\n    //   timeout: undefined\n    // }, {\n    //   id: 'posts-456',\n    //   priority: 1,\n    //   startTime: 1759253001916,\n    //   timeout: undefined\n    // }]\n    ```\n    */\n    get runningTasks() {\n        // Return fresh array with fresh objects to prevent mutations\n        return [...this.#runningTasks.values()].map(task => ({ ...task }));\n    }\n}\n/**\nError thrown when a task times out.\n\n@example\n```\nimport PQueue, {TimeoutError} from 'p-queue';\n\nconst queue = new PQueue({timeout: 1000});\n\ntry {\n    await queue.add(() => someTask());\n} catch (error) {\n    if (error instanceof TimeoutError) {\n        console.log('Task timed out');\n    }\n}\n```\n*/\nexport { TimeoutError } from 'p-timeout';\n"],"names":["assertPath","path","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","code","i","lastSlashIndex","_format","sep","pathObject","dir","base","posix","resolvedPath","resolvedAbsolute","cwd","process","isAbsolute","trailingSeparator","joined","arg","from","to","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","length","lastCommonSep","fromCode","toCode","out","hasRoot","end","matchedSlash","ext","start","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","pathBrowserify","TimeoutError","message","options","getAbortedReason","signal","pTimeout","promise","milliseconds","fallback","customTimers","timer","abortHandler","cancelablePromise","resolve","reject","timeoutError","error","lowerBound","array","value","comparator","first","count","step","it","PriorityQueue","#queue","run","priority","id","element","index","a","b","item","PQueue","EventEmitter","#carryoverIntervalCount","#isIntervalIgnored","#intervalCount","#intervalCap","#rateLimitedInInterval","#rateLimitFlushScheduled","#interval","#intervalEnd","#lastExecutionTime","#intervalId","#timeoutId","#strict","#strictTicks","#strictTicksStartIndex","#queueClass","#pending","#concurrency","#isPaused","#idAssigner","#runningTasks","#setupRateLimitTracking","#cleanupStrictTicks","now","oldestTick","#consumeIntervalSlot","#rollbackIntervalSlot","#getActiveTicksCount","#doesIntervalAllowAnother","#doesConcurrentAllowAnother","#next","#tryToStartAnother","#onResumeInterval","#onInterval","#initializeIntervalIfNeeded","#isIntervalPausedAt","delay","#createIntervalTimeout","timeSinceLastExecution","#clearIntervalTimer","#clearTimeoutTimer","taskStarted","canInitializeInterval","job","#scheduleRateLimitUpdate","#processQueue","newConcurrency","function_","taskSymbol","eventListener","#rollbackIntervalConsumption","operation","_resolve","result","functions","#updateRateLimitState","#onEvent","limit","handleError","event","filter","listener","previous","shouldBeRateLimited","task"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}
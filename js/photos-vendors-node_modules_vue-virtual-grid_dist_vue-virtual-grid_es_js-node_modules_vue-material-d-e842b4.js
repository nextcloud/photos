"use strict";
(self["webpackChunkphotos"] = self["webpackChunkphotos"] || []).push([["vendors-node_modules_vue-virtual-grid_dist_vue-virtual-grid_es_js-node_modules_vue-material-d-e842b4"],{

/***/ "./node_modules/vue-virtual-grid/dist/vue-virtual-grid.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vue-virtual-grid/dist/vue-virtual-grid.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VirtualGrid)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);

  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));


/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function (obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function reflectionIsSupported() {
  return typeof Reflect !== "undefined" && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
}

function copyReflectionMetadata(to, from) {
  forwardMetadata(to, from);
  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
    forwardMetadata(to.prototype, from.prototype, key);
  });
  Object.getOwnPropertyNames(from).forEach(function (key) {
    forwardMetadata(to, from, key);
  });
}

function forwardMetadata(to, from, propertyKey) {
  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
  metaKeys.forEach(function (metaKey) {
    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

    if (propertyKey) {
      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
    } else {
      Reflect.defineMetadata(metaKey, metadata, to);
    }
  });
}

var fakeArray = {
  __proto__: []
};
var hasProto = fakeArray instanceof Array;

function createDecorator(factory) {
  return function (target, key, index) {
    var Ctor = typeof target === "function" ? target : target.constructor;

    if (!Ctor.__decorators__) {
      Ctor.__decorators__ = [];
    }

    if (typeof index !== "number") {
      index = void 0;
    }

    Ctor.__decorators__.push(function (options) {
      return factory(options, key, index);
    });
  };
}

function isPrimitive(value) {
  var type = _typeof(value);

  return value == null || type !== "object" && type !== "function";
}

function collectDataFromConstructor(vm, Component2) {
  var originalInit = Component2.prototype._init;

  Component2.prototype._init = function () {
    var _this = this;

    var keys = Object.getOwnPropertyNames(vm);

    if (vm.$options.props) {
      for (var key in vm.$options.props) {
        if (!vm.hasOwnProperty(key)) {
          keys.push(key);
        }
      }
    }

    keys.forEach(function (key2) {
      Object.defineProperty(_this, key2, {
        get: function get() {
          return vm[key2];
        },
        set: function set(value) {
          vm[key2] = value;
        },
        configurable: true
      });
    });
  };

  var data = new Component2();
  Component2.prototype._init = originalInit;
  var plainData = {};
  Object.keys(data).forEach(function (key) {
    if (data[key] !== void 0) {
      plainData[key] = data[key];
    }
  });
  return plainData;
}

var $internalHooks = ["data", "beforeCreate", "created", "beforeMount", "mounted", "beforeDestroy", "destroyed", "beforeUpdate", "updated", "activated", "deactivated", "render", "errorCaptured", "serverPrefetch"];

function componentFactory(Component2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  options.name = options.name || Component2._componentTag || Component2.name;
  var proto = Component2.prototype;
  Object.getOwnPropertyNames(proto).forEach(function (key) {
    if (key === "constructor") {
      return;
    }

    if ($internalHooks.indexOf(key) > -1) {
      options[key] = proto[key];
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(proto, key);

    if (descriptor.value !== void 0) {
      if (typeof descriptor.value === "function") {
        (options.methods || (options.methods = {}))[key] = descriptor.value;
      } else {
        (options.mixins || (options.mixins = [])).push({
          data: function data() {
            return _defineProperty({}, key, descriptor.value);
          }
        });
      }
    } else if (descriptor.get || descriptor.set) {
      (options.computed || (options.computed = {}))[key] = {
        get: descriptor.get,
        set: descriptor.set
      };
    }
  });
  (options.mixins || (options.mixins = [])).push({
    data: function data() {
      return collectDataFromConstructor(this, Component2);
    }
  });
  var decorators = Component2.__decorators__;

  if (decorators) {
    decorators.forEach(function (fn) {
      return fn(options);
    });
    delete Component2.__decorators__;
  }

  var superProto = Object.getPrototypeOf(Component2.prototype);
  var Super = superProto instanceof vue__WEBPACK_IMPORTED_MODULE_0__["default"] ? superProto.constructor : vue__WEBPACK_IMPORTED_MODULE_0__["default"];
  var Extended = Super.extend(options);
  forwardStaticMembers(Extended, Component2, Super);

  if (reflectionIsSupported()) {
    copyReflectionMetadata(Extended, Component2);
  }

  return Extended;
}

var shouldIgnore = {
  prototype: true,
  arguments: true,
  callee: true,
  caller: true
};

function forwardStaticMembers(Extended, Original, Super) {
  Object.getOwnPropertyNames(Original).forEach(function (key) {
    if (shouldIgnore[key]) {
      return;
    }

    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

    if (extendedDescriptor && !extendedDescriptor.configurable) {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(Original, key);

    if (!hasProto) {
      if (key === "cid") {
        return;
      }

      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
        return;
      }
    }

    Object.defineProperty(Extended, key, descriptor);
  });
}

function Component(options) {
  if (typeof options === "function") {
    return componentFactory(options);
  }

  return function (Component2) {
    return componentFactory(Component2, options);
  };
}

Component.registerHooks = function registerHooks(keys) {
  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
};

globalThis && globalThis.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

function needToProduceProvide(original) {
  return typeof original !== "function" || !original.managed && !original.managedReactive;
}

function produceProvide(original) {
  var provide = function () {
    var _this = this;

    var rv = typeof original === "function" ? original.call(this) : original;
    rv = Object.create(rv || null);
    rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});

    for (var i in provide.managed) {
      rv[provide.managed[i]] = this[i];
    }

    var _loop_1 = function (i2) {
      rv[provide.managedReactive[i2]] = this_1[i2];
      Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i2], {
        enumerable: true,
        configurable: true,
        get: function () {
          return _this[i2];
        }
      });
    };

    var this_1 = this;

    for (var i in provide.managedReactive) {
      _loop_1(i);
    }

    return rv;
  };

  provide.managed = {};
  provide.managedReactive = {};
  return provide;
}

var reactiveInjectKey = "__reactiveInject__";

function inheritInjected(componentOptions) {
  if (!Array.isArray(componentOptions.inject)) {
    componentOptions.inject = componentOptions.inject || {};
    componentOptions.inject[reactiveInjectKey] = {
      from: reactiveInjectKey,
      default: {}
    };
  }
}

var reflectMetadataIsSupported = typeof Reflect !== "undefined" && typeof Reflect.getMetadata !== "undefined";

function applyMetadata(options, target, key) {
  if (reflectMetadataIsSupported) {
    if (!Array.isArray(options) && typeof options !== "function" && !options.hasOwnProperty("type") && typeof options.type === "undefined") {
      var type = Reflect.getMetadata("design:type", target, key);

      if (type !== Object) {
        options.type = type;
      }
    }
  }
}

function Prop(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, key) {
    applyMetadata(options, target, key);
    createDecorator(function (componentOptions, k) {
      (componentOptions.props || (componentOptions.props = {}))[k] = options;
    })(target, key);
  };
}

function ProvideReactive(key) {
  return createDecorator(function (componentOptions, k) {
    var provide = componentOptions.provide;
    inheritInjected(componentOptions);

    if (needToProduceProvide(provide)) {
      provide = componentOptions.provide = produceProvide(provide);
    }

    provide.managedReactive[k] = key || k;
  });
}

function Watch(path, options) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.deep,
      deep = _a === void 0 ? false : _a,
      _b = options.immediate,
      immediate = _b === void 0 ? false : _b;
  return createDecorator(function (componentOptions, handler) {
    if (typeof componentOptions.watch !== "object") {
      componentOptions.watch = /* @__PURE__ */Object.create(null);
    }

    var watch = componentOptions.watch;

    if (typeof watch[path] === "object" && !Array.isArray(watch[path])) {
      watch[path] = [watch[path]];
    } else if (typeof watch[path] === "undefined") {
      watch[path] = [];
    }

    watch[path].push({
      handler,
      deep,
      immediate
    });
  });
}

const getGridGapDefault = (elementWidth, windowHeight) => {
  if (elementWidth > 720 && windowHeight > 480) {
    return 10;
  } else {
    return 5;
  }
};

const getColumnCountDefault = elementWidth => {
  return Math.floor(elementWidth / 250);
};

const getWindowMarginDefault = windowHeight => {
  return Math.round(windowHeight * 1.5);
};

const getItemRatioHeightDefault = (height, width, columnWidth) => {
  const imageRatio = height / width;
  return Math.round(columnWidth * imageRatio);
};

const debugLog = function (condition) {
  if (condition) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    console.debug(...args);
  }
};

var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;

var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;

  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;

  if (kind && result) __defProp2(target, key, result);
  return result;
};

let VirtualGrid$1 = class extends vue__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(...arguments);
    this.updateLock = false;
    this.bottomReached = false;
    this.ref = null;
    this.containerData = {
      windowSize: {
        height: 0,
        width: 0
      },
      windowScroll: {
        x: 0,
        y: 0
      },
      elementWindowOffset: 0,
      elementSize: {
        height: 0,
        width: 0
      }
    };
  }

  get loadingBatch() {
    return this.loader && this.updateLock;
  }

  get configData() {
    return this.computeConfigData(this.containerData, this.items);
  }

  get layoutData() {
    return this.computeLayoutData(this.configData);
  }

  get renderData() {
    return this.computeRenderData(this.configData, this.containerData, this.layoutData);
  }

  mounted() {
    var _a;

    this.ref = this.$refs.virtualGrid;
    this.initiliazeGrid();
    window.addEventListener("resize", this.resize);
    ((_a = this.scrollElement) != null ? _a : window).addEventListener("scroll", this.scroll);
  }

  beforeDestroy() {
    var _a;

    window.removeEventListener("resize", this.resize);
    ((_a = this.scrollElement) != null ? _a : window).removeEventListener("scroll", this.scroll);
  }

  onScrollElementChanged(scrollElement, oldScrollElement) {
    (oldScrollElement != null ? oldScrollElement : window).removeEventListener("scroll", this.scroll);
    (scrollElement != null ? scrollElement : window).addEventListener("scroll", this.scroll);
  }

  resize() {
    this.loadMoreData();
  }

  scroll() {
    this.loadMoreData();
  }

  initiliazeGrid() {
    this.computeContainerData();
    this.$nextTick(async () => {
      this.loadMoreData();
    });
  }

  loadMoreData() {
    this.loadMoreDataAsync().catch(error => {
      if (error) {
        console.error("Fail to load next data batch", error);
      }
    }).then();
  }

  async loadMoreDataAsync() {
    this.computeContainerData();
    const windowTop = this.containerData.windowScroll.y;
    const windowBottom = windowTop + this.containerData.windowSize.height;
    const bottomTrigger = Math.max(0, this.containerData.elementWindowOffset + this.containerData.elementSize.height - this.updateTriggerMargin);

    if (!this.bottomReached && windowBottom >= bottomTrigger && !this.updateLock) {
      this.updateLock = true;
      debugLog(this.debug, "Loading next batch");
      const isLastBatch = await this.updateFunction();

      if (isLastBatch) {
        debugLog(this.debug, "Bottom reached");
        this.bottomReached = true;
      }

      this.updateLock = false;
      await this.loadMoreDataAsync();
    }

    return;
  }

  computeContainerData() {
    if (this.ref === null) {
      return;
    }

    const windowSize = this.getWindowSize();
    const windowScroll = this.getWindowScroll();
    const elementWindowOffset = this.getElementOffset(this.ref);
    const elementSize = this.getElementSize(this.ref);
    this.containerData = {
      windowSize,
      windowScroll,
      elementWindowOffset,
      elementSize
    };
  }

  computeConfigData(containerData, items) {
    if (containerData === null || items === null) {
      return {
        windowMargin: 0,
        gridGap: 0,
        columnCount: 1,
        entries: []
      };
    }

    const elementWidth = containerData.elementSize ? containerData.elementSize.width : 0;
    const windowMargin = this.getWindowMargin(containerData.windowSize.height);
    const gridGap = this.getGridGap(elementWidth, containerData.windowSize.height);
    const columnCount = this.getColumnCount(elementWidth);
    const columnWidth = this.getColumnWidth(columnCount, gridGap, elementWidth);
    const entries = items.map(item => {
      if (!item.width) {
        return item;
      }

      const imageWidth = columnWidth * item.columnSpan + gridGap * (item.columnSpan - 1);
      return __spreadProps(__spreadValues({}, item), {
        height: this.getItemRatioHeight(item.height, item.width, imageWidth),
        width: imageWidth
      });
    });
    return {
      windowMargin,
      gridGap,
      columnCount,
      entries
    };
  }

  computeLayoutData(configData) {
    if (configData === null) {
      return {
        cells: [],
        totalHeight: 0
      };
    }

    let currentRowNumber = 1;
    let prevRowsTotalHeight = 0;
    let currentRowMaxHeight = 0;
    let columnShift = 0;
    const cells = configData.entries.map((entry, index) => {
      const {
        columnCount,
        gridGap
      } = configData;
      let columnSpanRecompute = entry.columnSpan;
      let heightRecompute = entry.height;

      if (columnSpanRecompute < 1) {
        columnSpanRecompute = columnCount;
      }

      const distanceToRowStart = (index + columnShift) % columnCount;

      if (entry.newRow && distanceToRowStart !== 0) {
        columnShift += columnCount - distanceToRowStart;
      }

      const shiftedIndex = index + columnShift;
      const columnNumber = shiftedIndex % columnCount + 1;
      const rowNumber = Math.floor(shiftedIndex / columnCount) + 1;

      if (columnNumber + columnSpanRecompute > columnCount + 1) {
        const overlapNumber = columnNumber + columnSpanRecompute - columnCount - 1;
        const overlapRatio = overlapNumber / columnSpanRecompute;
        heightRecompute = heightRecompute * (1 - overlapRatio);
        columnSpanRecompute -= overlapNumber;
      }

      if (columnSpanRecompute > 1) {
        columnShift += columnSpanRecompute - 1;
      }

      if (rowNumber !== currentRowNumber) {
        currentRowNumber = rowNumber;
        prevRowsTotalHeight += currentRowMaxHeight + gridGap;
        currentRowMaxHeight = 0;
      }

      const offset = prevRowsTotalHeight;
      const height = Math.round(heightRecompute);
      currentRowMaxHeight = Math.max(currentRowMaxHeight, height);
      return __spreadProps(__spreadValues({}, entry), {
        columnNumber,
        rowNumber,
        offset,
        height,
        columnSpan: columnSpanRecompute
      });
    });
    const totalHeight = prevRowsTotalHeight + currentRowMaxHeight;
    return {
      cells,
      totalHeight
    };
  }

  computeRenderData(configData, containerData, layoutData) {
    if (layoutData === null || configData === null) {
      return {
        cellsToRender: [],
        firstRenderedRowNumber: 0,
        firstRenderedRowOffset: 0
      };
    }

    const cellsToRender = [];
    let firstRenderedRowNumber = null;
    let firstRenderedRowOffset = null;

    if (containerData.elementWindowOffset !== null) {
      const elementWindowOffset = containerData.elementWindowOffset;

      for (const cell of layoutData.cells) {
        const cellTop = elementWindowOffset + cell.offset;
        const cellBottom = cellTop + cell.height;
        const windowTop = containerData.windowScroll.y;
        const windowBottom = windowTop + containerData.windowSize.height;
        const renderTop = windowTop - configData.windowMargin;
        const renderBottom = windowBottom + configData.windowMargin;

        if (cellTop > renderBottom) {
          continue;
        }

        if (cellBottom < renderTop) {
          continue;
        }

        if (firstRenderedRowNumber === null) {
          firstRenderedRowNumber = cell.rowNumber;
        }

        if (cell.rowNumber === firstRenderedRowNumber) {
          firstRenderedRowOffset = firstRenderedRowOffset ? Math.min(firstRenderedRowOffset, cell.offset) : cell.offset;
        }

        cellsToRender.push(cell);
      }
    }

    return {
      cellsToRender,
      firstRenderedRowNumber,
      firstRenderedRowOffset
    };
  }

  getColumnWidth(columnCount, gridGap, elementWidth) {
    if (columnCount === null || gridGap === null || elementWidth === null) {
      return 0;
    }

    const totalGapSpace = (columnCount - 1) * gridGap;
    const columnWidth = Math.round((elementWidth - totalGapSpace) / columnCount);
    return columnWidth;
  }

  getGridRowStart(cell, renderData) {
    if (renderData === null) {
      return void 0;
    }

    const offset = renderData.firstRenderedRowNumber !== null ? renderData.firstRenderedRowNumber - 1 : 0;
    const gridRowStart = cell.rowNumber - offset;
    return `${gridRowStart}`;
  }

  resetGrid() {
    this.bottomReached = false;
    this.loadMoreData();
  }

  isSameElementSize(a, b) {
    return a.width === b.width && a.height === b.height;
  }

  getWindowSize() {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }

  getElementSize(element) {
    const rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height
    };
  }

  isSameElementScroll(a, b) {
    return a.x === b.x && a.y === b.y;
  }

  getWindowScroll() {
    return {
      x: window.scrollX,
      y: window.scrollY
    };
  }

  getElementOffset(element) {
    return window.scrollY + element.getBoundingClientRect().top;
  }

};

__decorateClass([Prop({
  required: true
})], VirtualGrid$1.prototype, "items", 2);

__decorateClass([Prop({
  default: () => () => true
})], VirtualGrid$1.prototype, "updateFunction", 2);

__decorateClass([Prop({
  default: () => getGridGapDefault
})], VirtualGrid$1.prototype, "getGridGap", 2);

__decorateClass([Prop({
  default: () => getColumnCountDefault
})], VirtualGrid$1.prototype, "getColumnCount", 2);

__decorateClass([Prop({
  default: () => getWindowMarginDefault
})], VirtualGrid$1.prototype, "getWindowMargin", 2);

__decorateClass([Prop({
  default: () => getItemRatioHeightDefault
})], VirtualGrid$1.prototype, "getItemRatioHeight", 2);

__decorateClass([Prop({
  default: null
})], VirtualGrid$1.prototype, "scrollElement", 2);

__decorateClass([Prop({
  default: 500
})], VirtualGrid$1.prototype, "updateTriggerMargin", 2);

__decorateClass([Prop({
  default: null
})], VirtualGrid$1.prototype, "loader", 2);

__decorateClass([Prop({
  default: false
})], VirtualGrid$1.prototype, "debug", 2);

__decorateClass([ProvideReactive()], VirtualGrid$1.prototype, "updateLock", 2);

__decorateClass([ProvideReactive()], VirtualGrid$1.prototype, "bottomReached", 2);

__decorateClass([ProvideReactive()], VirtualGrid$1.prototype, "ref", 2);

__decorateClass([ProvideReactive()], VirtualGrid$1.prototype, "containerData", 2);

__decorateClass([Watch("scrollElement")], VirtualGrid$1.prototype, "onScrollElementChanged", 1);

VirtualGrid$1 = __decorateClass([Component({
  name: "VirtualGrid"
})], VirtualGrid$1);

var render = function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c("div", {
    ref: "virtualGrid",
    style: {
      boxSizing: "border-box",
      height: _vm.layoutData.totalHeight + "px",
      paddingTop: _vm.renderData !== null && _vm.renderData.firstRenderedRowOffset !== null ? _vm.renderData.firstRenderedRowOffset + "px" : "0px"
    }
  }, [_c("div", {
    staticClass: "grid",
    style: {
      "display": "-ms-grid",
      "display": "grid",
      "align-items": "center",
      "grid-template-columns": "repeat(" + _vm.configData.columnCount + ", 1fr)",
      "gap": _vm.configData.gridGap + "px"
    }
  }, _vm._l(_vm.renderData.cellsToRender, function (item) {
    return _c("div", {
      key: item.id,
      staticClass: "grid-item-wrapper",
      style: {
        "height": item.height + "px",
        "grid-column-start": item.columnNumber,
        "grid-column-end": item.columnNumber + item.columnSpan,
        "grid-row-start": _vm.getGridRowStart(item, _vm.renderData)
      }
    }, [_c(item.renderComponent, _vm._g({
      tag: "component",
      attrs: {
        "item": item
      }
    }, _vm.$listeners))], 1);
  }), 0), _c(_vm.loadingBatch && _vm.loader, {
    tag: "component"
  })], 1);
};

var staticRenderFns = [];

function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;

  if (render2) {
    options.render = render2;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }

  if (functionalTemplate) {
    options.functional = true;
  }

  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    hook = function (context) {
      context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;

      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }

      if (injectStyles) {
        injectStyles.call(this, context);
      }

      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };

    options._ssrRegister = hook;
  } else if (injectStyles) {
    hook = shadowMode ? function () {
      injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
    } : injectStyles;
  }

  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return {
    exports: scriptExports,
    options
  };
}

const __cssModules = {};

var __component__ = /* @__PURE__ */normalizeComponent(VirtualGrid$1, render, staticRenderFns, false, __vue2_injectStyles, null, null, null);

function __vue2_injectStyles(context) {
  for (let o in __cssModules) {
    this[o] = __cssModules[o];
  }
}

var VirtualGrid = /* @__PURE__ */function () {
  return __component__.exports;
}();



/***/ }),

/***/ "./node_modules/vue-material-design-icons/ArrowLeft.vue":
/*!**************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/ArrowLeft.vue ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrowLeft.vue?vue&type=template&id=b9ea0198& */ "./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198&");
/* harmony import */ var _ArrowLeft_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ArrowLeft.vue?vue&type=script&lang=js& */ "./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _ArrowLeft_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__.render,
  _ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/vue-material-design-icons/ArrowLeft.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "ArrowLeftIcon",
  emits: ['click'],
  props: {
    title: {
      type: String,
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
});


/***/ }),

/***/ "./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js&":
/*!***************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_ArrowLeft_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/index.js??vue-loader-options!./ArrowLeft.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_ArrowLeft_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198&":
/*!*********************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198& ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_vue_loader_options_vue_loader_lib_index_js_vue_loader_options_ArrowLeft_vue_vue_type_template_id_b9ea0198___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../vue-loader/lib/index.js??vue-loader-options!./ArrowLeft.vue?vue&type=template&id=b9ea0198& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/ArrowLeft.vue?vue&type=template&id=b9ea0198& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    _vm._b(
      {
        staticClass: "material-design-icon arrow-left-icon",
        attrs: {
          "aria-hidden": !_vm.title,
          "aria-label": _vm.title,
          role: "img",
        },
        on: {
          click: function ($event) {
            return _vm.$emit("click", $event)
          },
        },
      },
      "span",
      _vm.$attrs,
      false
    ),
    [
      _c(
        "svg",
        {
          staticClass: "material-design-icon__svg",
          attrs: {
            fill: _vm.fillColor,
            width: _vm.size,
            height: _vm.size,
            viewBox: "0 0 24 24",
          },
        },
        [
          _c(
            "path",
            {
              attrs: {
                d: "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z",
              },
            },
            [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()]
          ),
        ]
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ })

}]);
//# sourceMappingURL=photos-vendors-node_modules_vue-virtual-grid_dist_vue-virtual-grid_es_js-node_modules_vue-material-d-e842b4.js.map?v=93137da1878b9b5e0ed0